diff a/SRC/js/game.js b/SRC/js/game.js	(rejected hunks)
@@ -1,4 +1,4 @@
-var snake = new Array(snakeSize),
+var snake,
     snakeSize,
     food,
     squareSize,
@@ -39,6 +39,7 @@
 
     create: function () {
         game.physics.startSystem(Phaser.Physics.ARCADE);
+        snake = [];             // This is a stack to store the snake parts
         snakeSize = 5;          // This is the size of the body of the snake
         food = {};              // Object for the food piece
         squareSize = 30;        // Size of the grid in pixels should be same as image size of snake sprites
@@ -211,49 +208,56 @@
             food.body.velocity.x = 0;
         }
 
-        if (Game.overlapAtOffset(food, sGroup, 16, -10)){
+        if (Game.overlapAtOffset(food, sGroup, 0, 0)){
             p1Win = true;
             newDirection = 'up';
+            alert("hit");
             game.state.start('GameOver');
         }
         Game.wallCollision(snake[0]);
-    },
 
-    //checks whether two sprites overlap up to a certain offset
+        game.add.text(350, 20, this.game.time.elapsedSecondsSince(startTime).toFixed(3), { font: '24px Arial', fill: '#0ff' });
+    },
+        
+    //checks whether two sprites overlap up to a certain offset 
     overlapAtOffsetSprite: function(object1, object2, offsetX, offsetY) {
+        var graphics = game.add.graphics(0, 0);
         //if either of the parameters passed aren't sprites
         if (typeof(object1.body) === "undefined" || typeof(object2.body) === "undefined") {
             return false;
         }
         //creates a new sprite shape from which the overlap will be greater dpeending on the offsets set by the user
-        var bounds1 = new Phaser.Rectangle(object1.position.x + object1.body.offset.x -
-            object1.anchor.x * object1.width / object1.scale.x +
-            offsetX, object1.position.y + object1.body.offset.y -
-            object1.anchor.y * object1.height / object1.scale.y +
-            offsetY, object1.body.width, object1.body.height);
+        var bounds1 = new Phaser.Rectangle((object1.position.x + object1.body.offset.x - 0.2 * object1.width / object1.scale.x + offsetX),(object1.position.y + object1.body.offset.y - 0 * object1.height / object1.scale.y + offsetY),(object1.body.width*0.4), (object1.body.height*0.4));
+        graphics.lineStyle(10, 0xFF0000, 0.8);
+        graphics.beginFill(0xFF700B, 1);
+        //graphics.drawRect((object1.position.x + object1.body.offset.x - 0.2 * object1.width / object1.scale.x + offsetX),(object1.position.y + object1.body.offset.y - 0 * object1.height / object1.scale.y + offsetY),(object1.body.width*0.4), (object1.body.height*0.4));
+        //graphics.drawRect((object2.position.x + object2.body.offset.x - 0.2 * object2.width / object2.scale.x),(object2.position.y + object2.body.offset.y - 0 * object2.height / object2.scale.y),(object2.body.width*0.6), (object2.body.height*0.6));
         //once again a larger shape is created
         var bounds2 = new Phaser.Rectangle(object2.position.x + object2.body.offset.x -
-            object2.anchor.x * object2.width / object2.scale.x,
+            0.2 * object2.width / object2.scale.x,
             object2.position.y + object2.body.offset.y -
-            object2.anchor.y * object2.height / object1.scale.y,
-            object2.body.width, object2.body.height);
+            0 * object2.height / object1.scale.y,
+            object2.body.width*0.6, object2.body.height*0.6);
+        game.draw
         return Phaser.Rectangle.intersects(bounds1, bounds2);
     },
     //this function is used when either of the sprites needed to be checked are a group of sprites
     overlapAtOffset: function(object1, object2, offsetX, offsetY) {
         //if the first parameter is a group rather than a singular sprite then loop check the overlap against every sprite
+        // object1.x += snake[i][0].width*0.5;
+        // object.x += snake[i][0].width*0.5;
         if (object1.physicsType == Phaser.GROUP) {
             for (var i = 0; i < object1.children.length; i++) {
                 if (Game.overlapAtOffset(object1.children[i], object2, offsetX, offsetY))
                     return true;
             }
-            //if the second parameter is a group, then loop
+        //if the second parameter is a group, then loop
         } else if (object2.physicsType == Phaser.GROUP) {
             for (var i = 0; i < object2.children.length; i++) {
                 if (Game.overlapAtOffset(object1, object2.children[i], offsetX, offsetY))
                     return true;
             }
-            //otherwise it is singular
+        //otherwise it is singular
         } else {
             return Game.overlapAtOffsetSprite(object1, object2, offsetX, offsetY);
         }
